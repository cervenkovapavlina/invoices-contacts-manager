from django.core.exceptions import ValidationError
from django.test import TestCase
from invoices.models import NumberRowPrefix, NumberRowValue
from django.utils import timezone
from datetime import datetime


class NumberRowTest(TestCase):
    """
    Regular user can create a new number row.
        A shared prefix is either generated or specified by the creator.
        Actual numbers/values are generated by the system.
        Generated values are consistent, without "missing values" in the row.
    Regular user can display a list of number rows.
    Regular user can display a detail page of a number row.
    """

    def tearDown(self):
        pass

    def prefix(self, name, prefix='', received=True):
        number_row_prefix = NumberRowPrefix(name=name, prefix=prefix, received=received)
        number_row_prefix.save()
        return number_row_prefix

    def value(self, prefix, year=datetime.now().year):
        number_row_value = NumberRowValue(prefix=prefix, year=str(year))
        number_row_value.save()
        return number_row_value

    def test_default_values(self):
        number_row_prefix = self.prefix(name="Rada faktur")
        self.assertGreater(number_row_prefix.id, 0, "number_row_prefix.id > 0")
        self.assertEqual(number_row_prefix.prefix, "", "number_row_prefix.prefix = \"\" ")
        self.assertTrue(number_row_prefix.received, "number_row_prefix.received = True")
        number_row_value = self.value(prefix=number_row_prefix)
        self.assertGreater(number_row_value.id, 0, "number_row_value.id > 0")
        self.assertEqual(number_row_value.value, 1, "number_row_value.value = 1")
        self.assertEqual(number_row_value.year, self.get_current_year(),
                         "number_row_value.year = self.get_current_year()")

    def test_identical_prefix_for_identical_invoice_type(self):
        prefix = "F"
        first_number_row_prefix = self.prefix(name="Prvni rada faktur", prefix=prefix)

        unique_exception = False
        try:
            second_number_row_prefix = self.prefix(name="Draha rada faktur", prefix=prefix)
        except ValidationError as e:
            self.assertEqual("Prefix already exists for the selected invoice type.", e.message,
                             "Prefix already exists for the selected invoice type. = e.message")
            unique_exception = True
        self.assertTrue(unique_exception, "unique_exception = True")

    def test_identical_prefix_for_different_invoice_types(self):
        prefix = "F"
        received_invoice_prefix = self.prefix(name="Prijate faktury", prefix=prefix)
        issued_invoice_prefix = self.prefix(name="Vystavene faktury", prefix=prefix, received=False)
        self.assertEqual(received_invoice_prefix.prefix, "F", "received_invoice_prefix.prefix = F")
        self.assertEqual(issued_invoice_prefix.prefix, "F", "issued_invoice_prefix.prefix = F")

        received_invoice_value = self.value(prefix=received_invoice_prefix, year="2025")
        issued_invoice_value = self.value(prefix=issued_invoice_prefix, year="2025")
        self.assertEqual(received_invoice_value.value, 1, "received_invoice_value.value = 1")
        self.assertEqual(issued_invoice_value.value, 1, "issued_invoice_value.value = 1")
        self.assertEqual(received_invoice_value.get_final_value(), "F20250001",
                         "received_invoice_value.get_final_value() = F20250001")
        self.assertEqual(issued_invoice_value.get_final_value(), "F20250001",
                         "issued_invoice_value.get_final_value() = F20250001")

    def test_multiple_number_row_values_with_identical_prefix_and_identical_or_different_year(self):
        # Zalozime prefix
        number_row_prefix = self.prefix(prefix="F", name="Rada faktur")

        # Vytvorime dve values do aktualniho roku
        first_value_in_current_year = self.value(prefix=number_row_prefix, year=self.get_current_year())
        second_value_in_current_year = self.value(prefix=number_row_prefix, year=self.get_current_year())
        self.assertEqual(first_value_in_current_year.value, 1, "first_value_in_current_year.value = 1")
        self.assertEqual(second_value_in_current_year.value, 2, "second_value_in_current_year.value = 2")

        # Vytvorime dve values do minuleho roku
        first_value_in_previous_year = self.value(prefix=number_row_prefix, year=self.get_previous_year())
        second_value_in_previous_year = self.value(prefix=number_row_prefix, year=self.get_previous_year())
        self.assertEqual(first_value_in_previous_year.value, 1, "first_value_in_previous_year.value = 1")
        self.assertEqual(second_value_in_previous_year.value, 2, "second_value_in_previous_year.value = 2")

    def test_multiple_number_row_values_with_identical_or_different_prefix_and_identical_year(self):
        # Zalozime dva prefixy
        received_invoice_prefix = self.prefix(prefix="PF", name="Prijate faktury")
        issued_invoice_prefix = self.prefix(prefix="VF", name="Vystavene faktury", received=False)

        # Pro prvni prefix zalozime dve values do aktualniho roku
        first_received_invoice_value = self.value(prefix=received_invoice_prefix, year=self.get_current_year())
        second_received_invoice_value = self.value(prefix=received_invoice_prefix, year=self.get_current_year())

        self.assertEqual(first_received_invoice_value.value, 1, "first_received_invoice_value.value = 1")
        self.assertEqual(second_received_invoice_value.value, 2, "second_received_invoice_value.value = 2")

        # Pro druhy prefix zalozime dve values do aktualniho roku
        first_issued_invoice_value = self.value(prefix=issued_invoice_prefix, year=self.get_current_year())
        second_issued_invoice_value = self.value(prefix=issued_invoice_prefix, year=self.get_current_year())

        self.assertEqual(first_issued_invoice_value.value, 1, "first_issued_invoice_value.value = 1")
        self.assertEqual(second_issued_invoice_value.value, 2, "second_issued_invoice_value.value = 2")

    def test_final_number_row_values(self):
        # Zalozime dva prefixy, jeden s defaultem, jeden zadany
        default_prefix = self.prefix(name="Defaultni rada faktur")
        given_prefix = self.prefix(prefix="F", name="Zadana rada faktur")

        count = 12
        this_year = 2025
        previous_year = this_year - 1

        # Pro oba prefixy vytvorime cyklem 'count' values pro rok 'this_year' a 'previous_year'
        for i in range(1, count):
            self.value(prefix=default_prefix, year=this_year)
            self.value(prefix=given_prefix, year=this_year)
            self.value(prefix=default_prefix, year=previous_year)
            self.value(prefix=given_prefix, year=previous_year)

        self.assert_first_and_last_value(this_year, default_prefix, count)
        self.assert_first_and_last_value(this_year, given_prefix, count)
        self.assert_first_and_last_value(previous_year, default_prefix, count)
        self.assert_first_and_last_value(previous_year, given_prefix, count)

    def make_invoice_number(self, year, prefix, value):
        return f"{prefix.prefix}{year}{value:04}"

    def assert_first_and_last_value(self, year, prefix, count):
        first_value_with_default_prefix = NumberRowValue.objects.filter(prefix=prefix, year=year, value=1)[0]
        last_value_with_default_prefix = NumberRowValue.objects.filter(prefix=prefix, year=year, value=count - 1)[0]

        first_expected_value = self.make_invoice_number(year, prefix,1)
        self.assertEqual(first_value_with_default_prefix.get_final_value(), first_expected_value,
        f"first_value_with_default_prefix.get_final_value() = {first_expected_value}")
        last_expected_value = self.make_invoice_number(year, prefix, count - 1)
        self.assertEqual(last_value_with_default_prefix.get_final_value(), last_expected_value,
                         f"eleventh_value_with_default_prefix_in_this_year.get_final_value() = {last_expected_value}")

    def get_current_year(self):
        return str(datetime.now().year)

    def get_previous_year(self):
        return str(datetime.now().year - 1)
